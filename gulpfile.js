// Require
const gulp = require('gulp');
const iconfont = require('gulp-iconfont');
const consolidate = require('gulp-consolidate');
const clean = require('gulp-clean');

// Package
var pkg = require('./package.json');

/**
 * Autogenerate assets.
 * $ gulp compile
 */
gulp.task('compile', function() {
  gulp.src('svg/*.svg')
    // Icon
    .pipe(iconfont({
      fontName: pkg.name,
      formats: ['ttf', 'eot', 'woff', 'woff2', 'svg'],
      //timestamp: Math.round(Date.now() / 1000),
      normalize: true,
      fontHeight: 1001
    }))
    // Glyphs
    .on('glyphs', function(glyphs, options) {
      // Conf
      var config =  {
        glyphs: glyphs.map(function(glyph) {
          return {
            name: glyph.name,
            codepoint: glyph.unicode[0].charCodeAt(0)
          }
        }),
        fontName: pkg.name,
        fontPath: '../fonts/',
        className: pkg.name
      };
      // Sass
      gulp.src('templates/' + pkg.name + '.scss')
        .pipe(consolidate('lodash', config))
        .pipe(gulp.dest('sass/'));
      // Css
      gulp.src('templates/' + pkg.name + '.css')
        .pipe(consolidate('lodash', config))
        .pipe(gulp.dest('css/'));
      // Html
      gulp.src('templates/' + pkg.name + '.html')
        .pipe(consolidate('lodash', config))
        .pipe(gulp.dest('./'));
    })
    // Fonts
    .pipe(gulp.dest('fonts/'));
});

/**
 * Clean autogenerated assets.
 * $ gulp clean
 */
gulp.task('clean', function() {
  gulp.src(['fonts', 'css', 'sass', '*.html'], { read: false })
    .pipe(clean());
});

/**
 * Build assets, and mimify.
 * $ gulp build
 */
gulp.task('build', ['clean', 'compile'])

/**
 * Execute on changes in assets.
 * $ gulp watch
 */
gulp.task('watch', function() {
  gulp.watch('templates/*', ['build']);
});

/**
 * Default.
 * $ gulp | gulp default
 */
gulp.task('default', ['build']);
